<a href="/README.md">вернуться к оглавлению</a><br>

<h3> Глава 4. Быстрая сортировка </h3>

РАЗДЕЛЯЙ И ВЛАСТВУЙ

Рекурсивная стратегия решения задач, которая заключается в приведении задачи <br> 
(упрощении, делении, уменьшении) к простейшему базовому случаю.

1. Сначала нужно найти этот базовый случай
2. Затем найти способ упростить исходную задачу до него

АЛГОИТМ ЕВКЛИДА

Примером применения стратегии "Разделяй и властвуй" является нахождение <br> 
наибольшего общего делителя двух чисел с помощью алгоритма Евклида

При этом числа постенно уменьшаются, пока не достигнут собственно <br>
значения наибольшего общего делителя.

**Пример**

У фермера есть большой прямоугольный участок земли. Он хочет разделить<br> 
его на *равные* *квадратные* участки максимального размера.

По сути эта задача сводится к нахождению НОД для длины и ширины исходного участка.

_Пример Nod в этой главе_


РАБОТА С МАССИВАМИ

_Пример суммы в массиве с использованием рекурсии - Sum_


БЫСТРАЯ СОРТИРОВКА

Алгоритм сортировки, основанный на принципе "Разделяй и властвуй".

Базовый случай - это массив с одним элементом, который сам по себе уже является <br> 
отсортированным. Базовым случаем также является пустой массив.

В исходном массиве выбирается `опорный` элемент. Затем массив делится на три части:

- элементы, которые *меньше* опорного
- опорный элемент
- элементы, которые *больше* опорного

Теперь задача сводится к двум меньшим задачам: отсортировать два подмассива.

Рекурсивное разделение происходит до тех пор, пока не будет достигнут базовый случай.

_Примеры сортировок Quick1 и Quick2 в данном разделе_ 


ЭФФЕКТИВНОСТЬ АЛГОРИТМА

Эффективность алгоритма во многом зависит от выбора `опорного` элемента.

**В худшем случае**: O(n<sup>2</sup>)

Массив уже отсортирован, в качестве опорного берется первый элемент.

**В среднем случае**: O(n * log n)

Массив уже отсортирован, в качестве опорного берется средний элемент.

На каждом витке алгоритм обращается ко всем элементам массива, независимо от того,<br> 
как они отсортированы. Поэтому эффективность зависит от высоты стека. В худшем случае <br> 
высота стека будет равна `n`. В лучшем случае высота стека `log n`, так как каждый раз <br>
массив делится на две равные части.

Сортировка слиянием (еще один алгоритм сортировки) имеет эффективность O(n * log n)<br> 
в худшем случае. Можно было бы предположить, что выгоднее всегда использовать сортировку<br> 
слиянием, а не быструю сортировку.

Однако при одинаковом времени O-большое эти алгоритмы имеют разное реальное время выполнения. <br> 
В O-большом игнорируется константа (время выполнения одной операции), но у быстрой сортировки <br>
она меньше, чем у сортировки слиянием.